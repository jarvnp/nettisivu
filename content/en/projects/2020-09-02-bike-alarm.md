---

title: Bike alarm
description: >-
  Not very surprisingly I got the idea for this project from a [Youtube-video](https://www.youtube.com/watch?v=CeStrH-5Llo). However I implemented the project very differently, because the SMS/GPS-module in the video was way too expensive (about 50€). I found a similar module from the internet for about 10€ and started then developing my own bike alarm system.
HTMLdescription: >-
  I built a bike alarm that sends me a text message, if my bikes moves when it shouldn't. While making the device there where ups and downs but at the end I was able to put together a working system.
singlePageContent: >-
  <img id=bike-alarm style="float: right; width: 500px" src="/img/bike-alarm-small.jpg" alt="The bike alarm attached below the bike's saddle">As a motion sensor I used MPU6050 gyroscope/accelerometer and particularly the accelerometer on it unlike in the video where a piezo crystal was used. The MPU6050 is controlled via I2C with an Atmega328P microcontroller. You can use the sensor so that it does measurements a few times per second and sleeps the rest of the time. (Consumes very little power.) When the sensor has done a measurement, one of its pins changes its state from 0 volts to 3.3 volts, which wakes up the microcontroller that was in deep (low power) sleep. The microcontroller then asks the sensor for the measurement result and saves it. Then everybody goes happily back to sleep unless the microcontroller thinks that there is something weird about the data. (weird = The acceleration value is bigger that what it should be, which means that the bike is being moved.) If there are multiple anomalous readings like this, the program I wrote concludes that the bike is being stolen. Then it wakes up the SMS-module which sends me a text message that tells the location of the bike and that it's being stolen.


  Me relationship with my original SMS/GPS-module was always quite bad. In other words, I either couldn't use it very well or it was just bad. It was always quite unreliable. You communicate with the module with AT-commands at a certain baud rate via UART. “A” in the word UART comes from "asynchronous", which means in this case that there is no clock signal, that would tell the communicating devices the speed that they should talk at. This caused me some trouble because of a previous decision on mine. I had decided to use the Atmega328P without an external 16 MHz crystal. Instead I used the microcontroller's internal 8 MHz oscillator. I did this because I wanted to test the Atmega328P without the external crystal and because the microcontroller's datasheet said that is shouldn't be used at low voltages at 16 MHz. I powered the microcontroller straight from a LiPo battery, so the voltage can go quite low. This could have perhaps maybe caused problems. I also wanted the device to be as small as possible, so I wanted to leave all not mandatory parts out. So I decided to use the internal oscillator. (In retrospect this caused me more trouble than just soldering the 16 MHz oscillator into the system and testing if it works reliably with the LiPo-battery.)


  The internal oscillator wasn't very accurate. I of course was aware of this based on the datasheet, but I thought it would be accurate enough. Well, communicating with the SMS-module was always unreliable and this is probably partly the reason behind that. The SMS-module has a feature that works so that when you turn it on, it automagically recognizes the baud rate that is used. This should be quite a simple procedure: 1) Turn on the module. 2) Send "AT", and the module answers "OK".


  In my case the procedure was: 1) Turn on the module. 2) Wait a specific amount of time, that you have tested to be good. If you wait for too long, nothing works. If you don't wait enough, nothing works. 3) Spam the module with "AT" until it hopefully answers "OK". For far too long I for some reason didn't doubt my contraption but just thought that the module I had ordered was bad.


  <div class=imgWithCaption style="float: left; width: 500px;"><img id=bike-alarm-old-module src="/img/bike-alarm-old-module-small.jpg" alt="The old SMS/GPS-module"><p class=caption>The old SMS/GPS-module</p></div>Actually I'm still not 100% sure whether the problems were caused by me or the module, since, as I recall, I had problems with the module even when testing it with a device that had a precise oscillator. Because of this I never actually tested if the problems were caused by my stupid decisions. I just assumed that the 10€ module has these features that I just have to deal with. In hindsight I was very stupid. I could have just plugged in an accurate 16 MHz crystal oscillator and tested if the problems go away.


  So I started making this project about two years ago (2018). I was able to make it about working, and I then attached it to my bike, where it was for at least a year. However at some point it stopped working. At that point I got frustrated and I ordered a new SMS-module. This was in the spring of 2020. This time I ordered an even cheaper module, but without GPS on it. I thought I would get good enough accuracy using mobile cell signal. The GPS in the original module was sometimes unreliable, and it never found signal indoors, and I thought this new method could be more reliable. The new module arrived, and it seemed almost perfect. When testing, it immediately answered my AT-command with OK. (This satisfied me after fighting for hours with the old module.) Getting the location data turned out to be more difficult than I thought. Luckily the new module was able to use the internet, because at the end I had to use Google Geolocation API, where the module sends information about the nearby cell towers and Google then gives me the location of the module. Unfortunately no matter how much I tried, the location accuracy was quite bad. The location is off for 500 meters at worst. Well, I thought it was better than nothing. Still I ordered also a new GPS-module, that I will maybe some day attach to the alarm system.


  So my new module worked perfectly on my work desk. Then I attached it to the alarm and SURPRISE, nothing works anymore. :)


  It was only then that I realized that the unreliability of the old module could be caused by my own mistakes. Still I didn't attach the old module back to the system for a few reasons: a) I didn't bother soldering the other module off and the other module back in again. b) I had fought with the old module so much that after detaching it I stuffed it to the bottom of my drawer and I never want to see it again.


  <img id=bike-alarm-inside style="float: left; width: 500px" src="/img/bike-alarm-inside-small.jpg" alt="Electronics of the alarm system. Atmega328P, SMS-module and its antenna, MOSFET, battery and wires.">Then I started fixing my mistakes. I plugged in a 16 MHz crystal oscillator. At this point I also changed the transistor that I used to switch on and off the SMS-module, because I thought there might be too big of a voltage drop across it. (Actually I'm not anymore sure if I changed it before or after I changed the module, but anyway I did the switch.) Originally I used a 2N2907 PNP-transistor to turn on and off the module. With a PNP-transistor so called [high side switching](https://www.baldengineer.com/low-side-vs-high-side-transistor-switch.html) was possible. At some point I started suspecting that my module might draw big amounts of current for short moments, and then my transistor wouldn't be powerful enough. This could also be the reason for the module's unreliability. Unfortunately I didn't have a better PNP-transistor or anything similar. I ended up using an N-channel MOSFET and low side switching. This is not optimal, because then the ground of the SMS-module and the microcontroller might not be exactly the same. Also then the module always has positive voltage connected to it. This shouldn't cause problems, because I made sure that current isn't able to flow to ground through the UART-connectors connected to the module when it's not powered. When the microcontroller turns off the module, it also changes the data pins connected to the module to input mode, so no current is able to flow through them.


  With these changes I got the module to work and my bike alarm was again functional. I am quite happy with its battery life. It has a small 300 mAh LiPo-battery that I had to charge about once every few months, when the alarm system was on for hours every day when I was in school. The alarm system can measure the battery's voltage using one of the Atmega328P's analog pins. The microcontroller can be programmed to make the analog measurements in relation to an internal constant voltage that's not dependent on the operating voltage. That's how it's possible to measure the battery's voltage. The alarm tells the voltage with a small LED when it's turned on and also with SMS when it alarms.



   To make things work I had to edit the code a bit when I changed the module. In the end the code is an absolutely horrible mess with a bit of the old code and a bit of the new. It's probably quite hard to understand. Anyways, it works, which is the main thing for me. I am (again) a bit embarrassed to publish that kind of code, but I will not start editing my code to be more publishable. I publish it as it was when the project was finished.


  [Link to the code](https://github.com/jarvnp/bikealarm)
order: 6

---
